from django.shortcuts import render, redirect #render - генерирует ответ
#на основании данных, полученных от представлений, redirect - используется
#для перенаправлени пользлвателя к странице (в данном случе topics)
from django.contrib.auth.decorators import login_required #импортируем функцию
#login_required. Саму функцию мы применяем перед всеми функциями, кроме index
from django.http import Http404 #импортируем сообщение об ошибке 404. Данная
#ошибка означает, что запрошенный ресурс не существует на сервере. 

from .models import Topic, Entry #импортируем модели, используемые в форме
from .forms import TopicForm, EntryForm #импортируем формы

def index(request):#если 
    #URL запроса совпадает с определенной схеиой URL, Django 
    #ищет в файле views.py функцию с именем index, после чего
    #передает этой функции представления объекта request. 
    #request - обязательный аргумент, так как он содержит
    #метаданные о запрсе, такие, как какой HTTP-запрос
    #используется, IP-адресс клиента и т.д.
    """Домашняя страница приложения Learning Log"""
    #В данном случае никакая обработка данных не требуется, 
    #поэтому код функции сводится к простому выводу render()
    return render(request, 'learning_logs/index.html')
    #второй аргумент request содержит в себе шаблон,
    #используемый для построения страницы

@login_required #знак @ сообщает Python, что код, содержащийся 
#в декораторе (по сути код, содержащийся в декораторе - это функция)
#должен выполняться перед кодом в def topics(...). 
#Сам код из login_required проверяет, вошел ли пользователь в систему
#и если вход был выполнен, то запускается функция topics. Если же вход 
#не был выполнен, то пользователь перенаправляется на страницу входа.
#Чтобы перенаправление работало, необходимо внести изменения в файл
#settings.py в конце файла.
def topics(request):
    """Выводит список тем"""
    topics = Topic.objects.filter(owner=request.user).order_by('date_added') 
    #request.user - если пользователь выполнил вход, то в
    #объекте запроса устанавливается атрибут request.user. 
    #Topic.objects.filter(owner=request.user) - приказывает Django извлечь из БД
    #только те объекты Topic, у которых атрибут owner соответствует текущему 
    #пользователю.
    #order_by('date_added') - выдается запрос
    #к базе данных на получение объектов Topic, отсортированных 
    #по атрибуту date_added.
    context = {'topics': topics} #определяем контекст, который
    #будет передаваться шаблону. 
    #Контекст представляет собой словарь, в котором ключами являются
    #имена, используемые в шаблоне для обращения к данным, а значениями
    # - данны, которые должны передаваться шаблону. 
    return render(request, 'learning_logs/topics.html', context)

@login_required
def topic(request, topic_id): #первая функция, которая получает что-то
    #кроме request. Функция получает значение, совпавшее с выражением
    #/<int:topic_id>/, и сохраняет его в topic_id
    """Выводит одну тему и все ее записи"""
    topic = Topic.objects.get(id=topic_id) #получаем тему (по аналогии с 
    #оболочкой)
    #Проверка того, что тема пренадлежит текущему пользователю
    check_topic_owner(topic, request)
    
    entries = topic.entry_set.order_by('-date_added') #загружаем даты для 
    #тем. Знак '-' перед date_added указывает на то, что мы сортируем 
    #даты обратном порядке, то есть самые новые записи будут находиться
    #на первых местах
    
    context = {'topic': topic, 'entries': entries}
    return render(request, 'learning_logs/topic.html', context)

@login_required
def new_topic(request):
    """Определяет новую тему"""
    if request.method != 'POST': #проверяется метод запроса. Если метод
        #запроса отличен от POST, то вероятно используется запрос GET,
        #поэтому необходимо вернуть пустую форму (даже если запрос другого
        #типа, это все равно безопасно)
        #Данные не отправлялись, создается пустая форма
        form = TopicForm() #так как при создании TopicForm аргументы не 
        #передавались, Django создает пустую форму, которая заполняется 
        #пользователем
    else: #если используется другой метод (в данном случае только POST),
        #выполняется блок else
        #Отправленные данные POST, обработать даныые
        form = TopicForm(data=request.POST) #создаем экземпляр формы и
        #передаем ему данные, введенные пользователем, хранящиеся в 
        #request.POST. Возвращаемый объект form содержит информацию,
        #отправленную пользователем
        if form.is_valid(): #отправленную информацию нельзя сохранить
            #до тех пор, пока она не будет проверена. Функция is_valid()
            #проверяет, что все обязательные поля были заполнены (все поля
            #формы являются обязательными по умолчанию), а введнные данные 
            #соответствуют типам полей, определенных в моделях, использемых
            #в формах
            new_topic = form.save(commit=False) #если все данные действительные, 
            #то они сохраняются. Метод save() записывает данные из формы в базу 
            #данных. При первом вызове form.save в качестве аргумента передается
            #значение commit=False, так как новая тема должна быть изменена перед
            #сохранением в БД.
            new_topic.owner = request.user #полю owner присваивается текущий
            #пользователь.
            new_topic.save() #после присвоения поля owner мы наконец сохраняем
            #форму в БД.
            return redirect('learning_logs:topics') #после сохранения данных
            #страница автоматически покидается (происходит перенапрвление
            #пользователя на страницу topics), где пользователь увидит 
            #только что введенную тему в списке общих тем
        
    #Вывести пустую или недействительную форму. Включается за блоками if-else
    #чтобы форма всегда отрисовывалась.
    context = {'form': form}
    return render(request, 'learning_logs/new_topic.html', context)

@login_required
def new_entry(request, topic_id):
    """Добавляет новую запись по конкретной теме"""
    topic = Topic.objects.get(id=topic_id) #нужен для отображения страницы
    #и обработки данных формы

    if request.method != 'POST':
        #Данные не отправлялись, создается пустая форма
        form = EntryForm()
    else:
        #Отправленны данные POST, обработать данные
        form = EntryForm(data=request.POST)
        if form.is_valid():
            new_entry = form.save(commit=False) #пока что не сохраняем на сервере 
            #введенные данные
            new_entry.topic = topic #к записи добавляем правильную тему, чтобы она 
            #с ней ассоциировалась
            new_entry.save() #после присвоения темы для записи мы сохраняем ее в БД
            return redirect('learning_logs:topic', topic_id=topic_id)
    
    #Выводит пустую или недействительную форму
    context = {'topic': topic, 'form': form}
    return render(request, 'learning_logs/new_entry.html', context)

@login_required
def edit_entry(request, entry_id):
    """Редактирует существующую запись"""
    entry = Entry.objects.get(id=entry_id) #получаем объект записи, который пользователь
    #хочет изменить
    topic = entry.topic #тема, связанная с записью, которую пользователь хочет изменить
    check_topic_owner(topic, request)

    if request.method != 'POST':
        #Исходный запрос, форма заполняется данными текущей записи
        form = EntryForm(instance=entry) #аргумент приказывает Django создать форму,
        #заранее заполненную информацией из существующего объекта записи. Пользователь
        #видит свои сущесвующие данные и может отредактировать их.
    else:
        #Отправка данных POST, обработать данные
        form = EntryForm(instance=entry, data=request.POST) #аргументы приказывают
        #Django создать экземпляр формы на основе существующего объекта записи 
        #(instance=entry) и обновленных данных из request.POST
        if form.is_valid():
            form.save()
            return redirect('learning_logs:topic', topic_id=topic.id)
    
    context = {'entry': entry, 'topic': topic, 'form': form}
    return render(request, 'learning_logs/edit_entry.html', context)

def check_topic_owner(topic, request):
    """Проверка пользователя"""
    if topic.owner != request.user: #перед выдачей темы мы убеждаемся, что
    #пользователь этой темы является текущем пользователем приложения. 
        raise Http404 #если тема не принадлежит текущему пользовател, то
        #выдается исключение Http404, а Django возвращает страницу с
        #сообщением о данной ошибке. 